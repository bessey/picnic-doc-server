#include "PicnicServer.h"
#include <stdio.h>
#include <string.h>
#include <cstdio>
#include <json/json.h>
#include "DBInterface.h"
#include <boost/filesystem.hpp>

using namespace boost;
using namespace filesystem;

PicnicServer::PicnicServer(std::string db_path, std::string directory)
{
    database = new DBInterface(db_path);
    doc_dir = directory;
}

PicnicServer::~PicnicServer()
{
    delete database;
}

// Process a string representing JSON input
// 1. convert message into JSON
// 2. get msgtype of message
// 3. send requisite data to specific function
// 4. return resulting string 
std::string PicnicServer::process(std::string user_id, std::string message)
{
    Json::Value data;
    Json::Reader reader;
    std::string msgtype;
    const std::string failure = "{\"msgtype\":\"null\"}";
	
    bool success = reader.parse(message, data);
    
    if(!success)
    {
        return failure;    
    }
    
    msgtype = data.get("msgtype", "failure").asString();
    
    if(msgtype == "get_unis")
        return getUnis();
    else if(msgtype == "get_solo_files")
        return getSoloFiles(user_id);
	else if(msgtype == "save_personal_data")
		return saveUserData(data, user_id);
    else if(msgtype == "retrieve_personal_data")
        return retrieveUserData(data, user_id);
    else if(msgtype == "doc_save")
        return saveDoc(data, user_id);
    else if(msgtype == "doc_new")
        return newDoc(data, user_id);
    else if(msgtype == "doc_open")
        return openDoc(data, user_id);
    else
        { return failure; }
    
}

// Retrieve a list of university data
std::string PicnicServer::getUnis()
{
    std::string message = "{\"msgtype\":\"get_unis\",\"unis\":";
    
    message += database->query("SELECT * FROM universities;", ALL);
    
    message += "}";
    
    return message;
}

// Retrieve a list of files on the server, with the courseIDs they are linked
// to, given a user.
std::string PicnicServer::getSoloFiles(std::string user_id)
{
    std::string message = "{\"msgtype\":\"get_solo_files\",\"files\":";
        
    message += database->query(
    "SELECT solo_docs.id, solo_docs.name, solo_docs.course_id, courses.name AS course_name, solo_docs.group_id "
    "FROM solo_docs "
    "INNER JOIN courses ON solo_docs.course_id = courses.id "
	"INNER JOIN users ON solo_docs.owner = users.id "
    "WHERE users.username = \"" + user_id + "\";", ALL);
    message += "}";
    
    return message;
}

// Open a document on the server
std::string PicnicServer::openDoc(Json::Value data, std::string user_id)
{
	Json::Reader reader;
	Json::Value docData;
	Json::Value output;
	std::string dir;	
	std::string doc_id = data["doc_id"].asString();
	std::string file_contents;
	std::string docInfo = database->query(
	    "SELECT courses.uni_id, solo_docs.group_id, solo_docs.course_id "
	    "FROM solo_docs "
	    "INNER JOIN courses ON solo_docs.course_id = courses.id "
	    "INNER JOIN universities ON courses.uni_id = universities.id "
	    "WHERE solo_docs.id = "+ doc_id +";", SINGLE);
	    
	if(docInfo == "success")
	{
		return "{\"msgtype\":\"doc_open\",\"response\":\"failure, doc id not in db\"}";
	}
	
	bool success = reader.parse(docInfo, docData);
	
	if(!success)
	{
	    return "{\"msgtype\":\"doc_open\",\"response\":\"could parse db json\"}";
	}   
	    
	std::string uni_id = docData["uni_id"].asString();
	std::string course_id = docData["course_id"].asString();
	std::string group_id = docData["group_id"].asString();
	long lSize;
	char * buffer;
	size_t result;
	// Check if there is an existing directory if not make it
    if(group_id == "-1")
    {
        dir = doc_dir + "/" + course_id + "/users/" + user_id + "/";
    } else {
        dir = doc_dir + "/" + course_id + "/groups/" + group_id +"/"+ user_id + "/";
    }

	std::string filepath = dir + doc_id + ".html";
	
	FILE* pFile = fopen(filepath.c_str(),"r");
	if(pFile == NULL){
		return "{\"msgtype\":\"doc_open\",\"response\":\"error file not found\" }";
	}
	// Obtain file size:
	fseek (pFile , 0 , SEEK_END);
	lSize = ftell (pFile);
	rewind (pFile);
	
	// Allocate memory to contain the whole file:
	buffer = (char*) malloc (sizeof(char)*lSize);
	if (buffer == NULL) {fputs ("Memory error",stderr); exit (2);}

	// Copy the file into the buffer:
	result = fread (buffer,1,lSize,pFile);
	if (result != lSize) {fputs ("Reading error",stderr); exit (3);}

	file_contents = std::string(buffer);

	// Terminate
	fclose (pFile);
	free (buffer);
	
	// TODO: Parse file contents and escape quotation marks
	output["msgtype"] = "doc_open";
	output["response"] = "success";
	output["file_contents"] = file_contents;
	output["doc_id"] = doc_id;
	Json::FastWriter writer;
	std::string output_string = writer.write(output);
	return output_string;
}

// Save a document on the server
std::string PicnicServer::saveDoc(Json::Value data, std::string user_id)
{	    
	Json::Reader reader;
	Json::Value docData;
	std::string dir;	
	std::string doc_id = data["doc_id"].asString();
	std::string file_contents = data["file_contents"].asString();
	std::string docInfo = database->query(
	    "SELECT courses.uni_id, solo_docs.group_id, solo_docs.course_id "
	    "FROM solo_docs "
	    "INNER JOIN courses ON solo_docs.course_id = courses.id "
	    "INNER JOIN universities ON courses.uni_id = universities.id "
	    "WHERE solo_docs.id = "+ doc_id +";", SINGLE);
	    
	if(docInfo == "success") // no rows in table :sadface:
	{
	    return "{\"msgtype\":\"doc_save\",\"response\":\"could not load doc info\"}";
	}
	
	bool success = reader.parse(docInfo, docData);
	
	if(!success)
	{
	    return "{\"msgtype\":\"doc_save\",\"response\":\"could not load doc\"}";
	}   
	    
	std::string uni_id = docData["uni_id"].asString();
	std::string course_id = docData["course_id"].asString();
	std::string group_id = docData["group_id"].asString();
        
	// Check if there is an existing directory if not make it
    if(group_id == "-1")
    {
        dir = doc_dir + "/" + course_id + "/users/" + user_id + "/";
    } else {
        dir = doc_dir + "/" + course_id + "/groups/" + group_id +"/"+ user_id + "/";
    }
    
    path p (dir);
    
    try
    {
        if(!exists(p) || !is_directory(p))
        {
            create_directories(p);
        }
    } catch (const filesystem_error& ex) {
        return "{\"msgtype\":\"doc_save\",\"response\":\"filesys failure\"}";
    }
		
	// Save contents to file
	std::string filepath = dir + doc_id + ".html";
    FILE* file = fopen(filepath.c_str(), "w");
    
    if(file == NULL)
        return "{\"msgtype\":\"doc_save\", \"response\":\"cannot open file\", \"filepath\":\""+filepath+"\"}";
    
    fprintf(file, "%s", file_contents.c_str());
    
    fclose(file);
		
    return "{\"msgtype\":\"doc_save\", \"response\":\"success\"}";
}

// Remove a document from the database and delete the file
void PicnicServer::deleteDoc(Json::Value* data, std::string user_id)
{
}

// Registers a new doc in the database BUT DOES NOT save any file data
std::string PicnicServer::newDoc(Json::Value data, std::string user_id)
{
    Json::Reader reader;
    Json::Value docData;
    std::string group_id = data["group_id"].asString();    
    std::string course_id = data["course_id"].asString(); 
    std::string name = data["name"].asString();    
    std::string description = data["description"].asString();
    std::string doc_id;
    std::string user_id_int = getIdFromName(user_id);
    
    std::string insert = "INSERT INTO solo_docs "
    "VALUES(null,\""+name+"\","+user_id_int+","+course_id+",0,0,"
    +group_id+",\""+description + "\");";
    
    std::string result = database->query(insert, ALL);
    
    if(result != "success")
    {
        return "{\"msgtype\":\"doc_new\",\"response\":\"insert fail\"}";
    }
    
    std::string id_get= database->query(
    "SELECT MAX(id) FROM solo_docs;", SINGLE);
    
    bool success = reader.parse(id_get, docData);
    
    if(!success)
    {
        return "{\"msgtype\":\"doc_new\",\"response\":\"doc_id retrieve fail\"}";
    }
    
    doc_id = docData["MAX(id)"].asString();
    
    return "{\"msgtype\":\"doc_new\",\"response\":\"success\""
           ",\"doc_id\":\""+doc_id+"\"}";
}

// Returns the courses at a specific university
void PicnicServer::getCourses(Json::Value* data)
{
}
        
// Retrieve courses for a specific user
void PicnicServer::getUserCourses(std::string user_id)
{
}

// Saves user data in table
std::string PicnicServer::saveUserData(Json::Value data, std::string user_id)
{
	std::string first_name = data["first_name"].asString();
	std::string last_name = data["last_name"].asString();
	std::string uni_id = data["uni_id"].asString();
	std::string email = data["email"].asString();
	std::string lecturer = data["lecturer"].asString();
	
	std::string query = "UPDATE users SET( "
	"'firstname' = '"+first_name+"', "
	"'surname' = '"+last_name+"', "
	"'uni_id' = '"+uni_id+"', "
	"'email' = '"+email+"', "
	"'lecturer' = '"+lecturer+"' "
	") WHERE username = '" + user_id + "';";
	std::string message = "{\"msgtype\":\"save_personal_data\",\"response\":";
	message += database->query(query, ALL);
	message += "}";
	
	return message;
}

// Retrieve personal user data from table
std::string PicnicServer::retrieveUserData(Json::Value data,std::string user_id)
{
    std::string user_id_int = getIdFromName(user_id);
    std::string message = "{\"msgtype\":\"save_personal_data\",\"response\":";
    
    std::string query =
    "SELECT username, firstname, surname, email, uni_id, lecturer "
    "FROM users "
    "WHERE id = "+user_id_int+";";
    
    std::string result = database->query(query, SINGLE);
    
    if(result == success)
        return message + "\"unknown user/user_id\"}";
        
    message += "\"success\","
    message += result.substr(1, str.length()-2) + "}";// trimming off { }
    
    return message;
}

// Gets the user_id based on a name
std::string PicnicServer::getIdFromName(std::string user_id)
{    
    Json::Reader reader;
    Json::Value data;
    std::string id = database->query(
    "SELECT id FROM users WHERE username = \""+user_id+"\";", SINGLE);
    
    reader.parse(id, data);
    
    return data["id"].asString();
}
